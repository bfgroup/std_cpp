= C++ Compile
:copyright: Copyright 2017-2018 Rene Rivera
:author: Rene Rivera
:email: grafikrobot@gmail.com
:revnumber: D0xxxR0
:revdate: {docdate}
:revremark: Initial
:version-label!: 
:reproducible:
:nofooter:
:sectanchors:
:sectnums:
:source-highlighter: highlightjs
:source-language: c++
:toc: left
:toclevels: 3
:caution-caption: ⚑
:important-caption: ‼
:note-caption: ℹ
:tip-caption: ☀
:warning-caption: ⚠
:CPP: C++

ifdef::backend-html5[]
++++
<style>
include::std.css[]
</style>
++++
endif::[]

[horizontal]
Document number:: {revnumber}
Date:: {revdate}
Reply-to:: {author}, {email}
Audience:: Study Group 15, Library Evolution

== Introduction

This proposes the addition of an interface for transforming {CPP} source into
usable binary images. As such it aims to provide a common definition of
existing compiler frontend tool options for generating programs and libraries
for translation units.

=== Background and Motivation

This proposal is based on the notion that it should be possible for a {CPP}
user, both beginner and advanced, to easily transform their source to
immediately executable form in a consistent method across compilers.

One key aspect of this proposal is to make it possible for future {CPP}
educators, and book authors, to provide complete usage examples that work for
any particular tool they and their audience use. While this proposal does not
prescribe a particular executable tool, it is trivial to write minimal tool
that passes arguments directly to these interfaces.

It is also the intent for this proposal to be an initial step in the road
towards standardizing the tooling around {CPP}. With the goal of having a
global and consistent tooling ecosystem to facilitate the introduction into
{CPP} for anyone and to ease the interoperability of future tooling.

=== Impact On the Standard

This proposal is a library extension and specification. As such it does not
proscribe changes to any standard classes or functions. It adds one function
and some definitions to a new header file, `<compile>`.

=== Design Goals

The design herein is driven primarily by the following, in approximate
order of importance:

* Mirror the `main` entry point to make a frontend program trivial.
* Minimize variability in arguments and options.
* Use common practice option names for familiarity.
* Do not attempt to specify all possible options as that's not technically
possible.
* Specify how, and if, options are compatible with others.

=== Design Decisions

==== Exceptions

So as to reduce error handling cases for callers of `compile`, i.e. `main`,
there are no exceptions allowed from calls to `compile`. This has the effect
of removing the need for exception handling at the caller as any error
situations are indicated by the simpler return value which can be directly
mapped to the return value of `main`.

==== Vendor Arguments

Recognizing that specifying a complete set of argument options is not possible
we need to provide for a mechanism to pass vendor specific arguments for
compilation; but at the same time we want to ensure that defined arguments
are not ignored in favor of vendor only arguments. Hence we specify this
implementation rule:

When a defined argument option exists a vendor specific argument is *not*
allowed as an acceptable argument option.

For instance::
??

==== Extension Arguments

Given the faster rate at which compilers change with respect to the {CPP}
standard we need to allow for specification of arguments as quickly as
possible to facilitate support in tooling.

For instance::
A vendor release a new version of their compiler to support a new CPU.
This new CPU is not compatible with an existing CPU and hence packages must
be recompiled for it. But the next possibility scheduled committee meeting
that could approve adding that new CPU option is months later.

==== `+` Option Prefix

Like choosing names for programming language constructs, choosing a prefix
for the option arguments is a contentious decision. For this we chose to
use `+` as the prefix, and hence `++` for the long form, for these reasons:

* It's not used in current compiler tooling and hence avoids confusion with
existing options.
* It doesn't conflict with operating system specific path specifications.
* Is a non-alphanumeric ASCII glyph.
* Not frequently used as the first character of file names.
* And finally, it harkens to {CPP} itself.

==== Use Cases

This facility is designed to facilitate primarily two groups of users:
teachers (and their students), and tool creators. For teachers this feature
would improve, by simplifying, the teaching materials presented to students.

For instance::
???

For tool creators the uses vary depending on the tools in question. They could
be a build system, like `b2` (aka Boost.Build) that has complicated toolset
definition files that translate portable build descriptions to specific
tool invocations.

For instance::
In `b2` one would indicate include search paths by adding
`<include>my/include` to the specification of the build definition. It will
then translate that to a compile invocation depending on the tool:
`cl.exe /I "my/include"`, `cc -Imy/include`, `bcc32.exe -I"my/include"`,
`clang -I"my/include"`, `gcc -I"my/include"`, `cl.exe /I"my/include"`, and so
on. This is obviously a very simple example and the options get less uniform
across compilers the more "esoteric" the options are. And the build system
needs lots of human programed knowledge to create these mappings. Instead
with this proposal the mapping would be universal and only non-core options
and the tool executable would need special treatment.

Publishing libraries, with or without source, also poses a problem for those
doing the publishing. As part of publishing your library will have specific
options it needs your program to compile with to make use of the library. This
can involve rather complex distributions to account for the varied compilers
end users have. And many times this involves publishing many different files
for each possible configuration and compiler you support.

For instance::
One common method of doing that is to use pkg-config. You might end up with
this kind of file for GCC:
+
----
Name: libpng
Description: Loads and saves PNG files
Version: 1.2.8
Libs: -L${libdir} -lpng12 -lz
Cflags: -I${includedir}/libpng12
----
+
And another for MSVC:
+
----
Name: libpng
Description: Loads and saves PNG files
Version: 1.2.8
Libs: /LIBPATH:${libdir} png12.lib z.lib
Cflags: /I${includedir}/libpng12
----
+
With this proposal it would be possible to only include one such file
regardless of compiler used:
+
----
Name: libpng
Description: Loads and saves PNG files
Version: 1.2.8
Libs: ++library_path=${libdir} +lpng12 +lz
Cflags: +I${includedir}/libpng12
----

== Technical Specification

=== Header `<compile>` Synopsis

----
namespace std
{
  int compile(int, char * *) noexcept;
}
----

=== Specification

----
int compile(int argument_count, char * * arguments) noexcept;
----

[horizontal]

Requires:: `argument_count > 0`, where `arguments[0]` is the name of the
program executable. And `arguments[1..argument_count)` are either either
options or names of source files.

Effect:: Executes the compilation according to the given `arguments`.

Returns:: zero (`0`) for success, non-zero (`!= 0`) for an error.

==== Arguments

The `arguments` specify the set of options and source translation units to
compile.

Options, and their values, can be "link incompatible". Wherein translation
units compiled with differing options or values can not be linked together
into a program.

===== Core Options

include::../src/opt_core.cpp[leveloffset=+5,tag=std_cpp]

== Prior Art

=== `B2` build system

The `B2` (aka Boost Build) build system uses the concept of features to
portably abstract the declaration of compiler options to a portable
specification. For example:

* `optimization=off` would add the compiler specific option to turn off
  any code optimization.
* `debug-symbols=on` would add the compiler specific option to add source
  level debugging information to the output.
* `address-model=64` would add compiler specific options to generate
  64-bit addressing only code.

=== `clang-cl`

The Microsoft Visual Studio development environment support using Clang
as an alternative compiler to their msvc (`cl.exe`) compiler. In order
to avoid reflecting the Clang specific options up into the IDE
Visual Studio implements a compiler front end that translates from
msvc options to Clang options (`clang-cl.exe`).

=== Cmake build system

Like the features of `b2` modern Cmake also implements a series of
variables that provide an abstraction to common compiler options.
For example:

* `set_property(TARGET foo PROPERTY CXX_STANDARD 11)` would add the compiler
  specific option to restrict compilation to use Standard C++11 features.

== Acknowledgements

